# Interface Specification

This is a quick doc describing how I want it work, so I don't change my mind halfway through coding it ;-)

It may not be a description of how it currently works...

## EXECUTE

## Inputs

```json
{
  action: 'execute',
  stmt:   'CREATE TABLE testing ( id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) NOT NULL, name VARCHAR(80), age  INTEGER, CONSTRAINT testid PRIMARY KEY ( id ) )'
}
```

### OUTPUTS

```json
{
  "status":"ok"
}
```
or
```json
{
  "status": "error",
  "exception": "message"
}
```

## SELECT

### Inputs

```json
{
  "action": "select",
  "stmt": "SELECT * FROM xxx"
}
```
or
```json
{
  "action": "select",
  "stmt": "SELECT * FROM xxx WHERE a=? AND b=?",
  "params": [ { "a":10, "b":20 }, ... ]
}
```
or
```json
{
  "action": "select",
  "stmt": "SELECT * FROM xxx WHERE a=? AND b=?",
  "params": [ { "a":10, "b":20 }, ... ],
  "batchsize": 10
}
```

### Outputs

One of:

```json
{
  "status": "ok",
  "result": [ { "NAME":"a", "AGE":32 }, ... ]
}
```
```json
{
  "status": "partial",
  "result": [ { "NAME":"a", "AGE":32 }, ... ]
}
```
```json
{
  "status": "error",
  "exception": "message"
}
```

> If batchSize is less than available number of records, then partial result will be returned, and user will need to make another query to the replier within 10 seconds to get the next batch of data.  If 10 seconds pass with no query, the resultset and statement are closed automatically.  If we are not within a transaction (see below), the connection is closed as well.

## INSERT

### Inputs

```json
{
  "action": "insert",
  "stmt": "INSERT INTO xxx( a, b ) VALUES( ?, ? )",
  "transaction":"yes",
  "params": [ [ 10, 20 ], ... ]
}
```
### Outputs

One of:

```json
{
  "status": "ok",
  "result": [ { "ID":1 }, { "ID":2 }, ... ]
}
```
or
```json
{
  "status": "error",
  "exception": "message"
}
```

> Wrapped in a transaction if none exists or unless transaction='no'. If primary keys are generated by the insert, then the values are returned in the result section of the response.

## UPDATE

### Inputs

```json
{
  "action":"update"
  "stmt": "UPDATE xxx SET( a=?, b=? ) WHERE c=?",
  "transaction":"yes",
  "params": [ [ 10, 20, 30 ], ... ]
}

### OUTPUTS

```json
{
  "status":"ok",
  "updated":nrows
}
```
or
```json
{
  "status": "error",
  "exception": "message"
}
```

## TRANSACTION

### Inputs

```json
{
  "action": "transaction",
  "timeout": 10
}
```

### OUTPUTS

```json
{
  "status":"ok"
}
```
or
```json
{
  "status": "error",
  "exception": "message"
}
```

> This starts a transaction on the current conversation.  After each response, if no reply is heard for more than 10 seconds (the default), then the transaction is rolled back and the connection is closed.  It must be then followed up by one of the following:

## COMMIT

### Inputs

```json
{
  "action": "commit"
}
```

### OUTPUTS

```json
{
  "status":"ok"
}
```
or
```json
{
  "status": "error",
  "exception": "message"
}
```

## ROLLBACK

### Inputs

```json
{
  "action": "rollback"
}
```

### OUTPUTS

```json
{
  "status":"ok"
}
```
or
```json
{
  "status": "error",
  "exception": "message"
}
```
